/**
 * Module dependencies.
 */

var uid2 = require('uid2');
var redis = require('redis').createClient;
var msgpack = require('notepack.io');
var Adapter = require('socket.io-adapter');
var debug = require('debug')('socket.io-redis');

/**
 * Module exports.
 */

module.exports = adapter;

/**
 * Request types, for messages between nodes
 * 消息在节点之间传递消息的请求类型
 */

var requestTypes = {
    clients: 0,
    clientRooms: 1,
    allRooms: 2,
    remoteJoin: 3,
    remoteLeave: 4,
    customRequest: 5,
    remoteDisconnect: 6
};

/**
 * Returns a redis Adapter class.返回一个设配器类
 *
 * @param {String} optional, redis uri
 * @return {RedisAdapter} adapter
 * @api public
 */

function adapter(uri, opts) {
    opts = opts || {};

    // handle options only
    if ('object' == typeof uri) {
        opts = uri;
        uri = null;
    }

    // opts
    var pub = opts.pubClient;
    var sub = opts.subClient;
    var prefix = opts.key || 'socket.io';
    // 请求超时时间
    var requestsTimeout = opts.requestsTimeout || 5000;

    // init clients if needed
    function createClient() {
        if (uri) {
            // handle uri string
            return redis(uri, opts);
        } else {
            return redis(opts);
        }
    }

    if (!pub) pub = createClient();
    if (!sub) sub = createClient();

    // this server's key
    var uid = uid2(6); // 标识该服务器

    /**
     * Adapter constructor.适配器构造函数
     *
     * @param {String} namespace name
     * @api public
     */

    function Redis(nsp) {
        Adapter.call(this, nsp); // 调用socket.io-adapter中构造函数

        this.uid = uid; // 标识该服务器
        this.prefix = prefix; // 前缀
        this.requestsTimeout = requestsTimeout; // 请求超时时间

        this.channel = prefix + '#' + nsp.name + '#'; // 指定命名空间的全局广播频道名称
        // 指定命名空间的请求通道，如果有房间，则作为频道前缀
        this.requestChannel = prefix + '-request#' + this.nsp.name + '#';
        // 指定命名空间的响应通道，如果有房间，则作为频道前缀
        this.responseChannel = prefix + '-response#' + this.nsp.name + '#';
        this.requests = {}; // 保存自己发出的请求信息
        // 自定义请求构造函数
        this.customHook = function (data, cb) {
            cb(null);
        }

        // 频道匹配函数
        if (String.prototype.startsWith) {
            this.channelMatches = function (messageChannel, subscribedChannel) {
                return messageChannel.startsWith(subscribedChannel);
            }
        } else { // Fallback to other impl for older Node.js
            this.channelMatches = function (messageChannel, subscribedChannel) {
                return messageChannel.substr(0, subscribedChannel.length) === subscribedChannel;
            }
        }
        this.pubClient = pub; // 发布消息连接
        this.subClient = sub; // 订阅消息连接

        var self = this;

        // 订阅频道，这里是命名空间的每个房间创建一个频道
        sub.psubscribe(this.channel + '*', function (err) {
            if (err) self.emit('error', err); // 错误处理， 发出error事件
        });

        // 监听消息
        sub.on('pmessageBuffer', this.onmessage.bind(this));

        // 在启动时订阅当前命名空间的请求和响应频道
        sub.subscribe([this.requestChannel, this.responseChannel], function (err) {
            if (err) self.emit('error', err); // 错误处理， 发出error事件
        });

        // 监听消息
        sub.on('messageBuffer', this.onrequest.bind(this));

        function onError(err) { // 发出error事件
            self.emit('error', err);
        }

        pub.on('error', onError);
        sub.on('error', onError);
    }

    /**
     * Inherits from `Adapter`.
     */

    Redis.prototype.__proto__ = Adapter.prototype; // 原型继承

    /**
     * Called with a subscription message 订阅消息回调
     *
     * @api private
     */

    Redis.prototype.onmessage = function (pattern, channel, msg) {
        channel = channel.toString();

        // 频道不同，则忽略信息
        if (!this.channelMatches(channel, this.channel)) {
            return debug('ignore different channel');
        }

        // 获取频道对应的房间
        var room = channel.slice(this.channel.length, -1);
        // 虽然房间名称不为空，但本地节点服务器的命名空间没有该房间
        if (room !== '' && !this.rooms.hasOwnProperty(room)) {
            return debug('ignore unknown room %s', room);
        }

        var args = msgpack.decode(msg); // 解码消息
        var packet;

        // 如果消息是本服务器节点发出去的，就没有必要处理该消息
        if (uid === args.shift()) return debug('ignore same uid');

        packet = args[0]; // 获取消息包

        if (packet && packet.nsp === undefined) {
            packet.nsp = '/';
        }

        // 如果不是当前命名空间的消息包，则丢弃
        if (!packet || packet.nsp != this.nsp.name) {
            return debug('ignore different namespace');
        }

        args.push(true); // 标记当前消息是远程转发

        this.broadcast.apply(this, args); // 在当前节点服务器指定命名空间内广播
    };

    /**
     * Called on request from another node 其它节点请求回调
     *
     * @api private
     */

    Redis.prototype.onrequest = function (channel, msg) {
        channel = channel.toString();

        if (this.channelMatches(channel, this.responseChannel)) {
            return this.onresponse(channel, msg); // 这里是处理响应
        } else if (!this.channelMatches(channel, this.requestChannel)) {
            return debug('ignore different channel');
        }

        // 下面是处理请求
        var self = this;
        var request;

        try {
            request = JSON.parse(msg); // 解析消息
        } catch (err) {
            self.emit('error', err);
            return;
        }

        debug('received request %j', request);

        switch (request.type) {

            case requestTypes.clients: // 查询指定房间的所有连接
                Adapter.prototype.clients.call(self, request.rooms, function (err, clients) {
                    if (err) {
                        self.emit('error', err);
                        return;
                    }

                    // 响应内容编码
                    var response = JSON.stringify({
                        requestid: request.requestid,
                        clients: clients // 返回收集的sid
                    });

                    pub.publish(self.responseChannel, response); // 发布到响应频道
                });
                break;

            case requestTypes.clientRooms: // 查询连接所在的所有房间
                Adapter.prototype.clientRooms.call(self, request.sid, function (err, rooms) {
                    if (err) {
                        self.emit('error', err);
                        return;
                    }

                    if (!rooms) {
                        return;
                    }

                    var response = JSON.stringify({
                        requestid: request.requestid,
                        rooms: rooms // 返回收集的房间
                    });

                    pub.publish(self.responseChannel, response); // 发布到响应频道
                });
                break;

            case requestTypes.allRooms: // 查询当前命名空间的所有房间

                var response = JSON.stringify({
                    requestid: request.requestid,
                    rooms: Object.keys(this.rooms) // 返回收集的房间
                });

                pub.publish(self.responseChannel, response); // 发布到响应频道
                break;

            case requestTypes.remoteJoin: // 指定的连接加入指定的房间

                // 判断当前节点是否包含该连接，如果不包含则直接返回
                var socket = this.nsp.connected[request.sid];
                if (!socket) {
                    return;
                }

                // 如果包含该连接，则执行加入
                socket.join(request.room, function () {
                    var response = JSON.stringify({
                        requestid: request.requestid
                    });

                    pub.publish(self.responseChannel, response); // 发布到响应频道
                });
                break;

            case requestTypes.remoteLeave: // 指定的连接离开指定的房间

                // 判断当前节点是否包含该连接，如果不包含则直接返回
                var socket = this.nsp.connected[request.sid];
                if (!socket) {
                    return;
                }

                // 如果包含该连接，则执行离开
                socket.leave(request.room, function () {
                    var response = JSON.stringify({
                        requestid: request.requestid
                    });

                    pub.publish(self.responseChannel, response);
                });
                break;

            case requestTypes.remoteDisconnect: // 断开指定的连接

                // 判断当前节点是否包含该连接，如果不包含则直接返回
                var socket = this.nsp.connected[request.sid];
                if (!socket) {
                    return;
                }

                // 如果包含该连接，则执行断开
                socket.disconnect(request.close);

                var response = JSON.stringify({
                    requestid: request.requestid
                });

                pub.publish(self.responseChannel, response);
                break;

            case requestTypes.customRequest: // 发送一个定制请求到其它节点
                // 调用自定义钩子函数
                this.customHook(request.data, function (data) {

                    var response = JSON.stringify({
                        requestid: request.requestid,
                        data: data // 收集的响应数据
                    });

                    pub.publish(self.responseChannel, response);
                });

                break;

            default:
                debug('ignoring unknown request type: %s', request.type);
        }
    };

    /**
     * Called on response from another node 其它节点响应回调
     *
     * @api private
     */

    Redis.prototype.onresponse = function (channel, msg) {
        var self = this;
        var response;

        try {
            response = JSON.parse(msg); // 解析消息
        } catch (err) {
            self.emit('error', err);
            return;
        }

        var requestid = response.requestid;

        if (!requestid || !self.requests[requestid]) { // 如果不是自己发出的请求，则不会处理
            debug('ignoring unknown request');
            return;
        }
        // 如果是自己发出的请求，则会继续处理
        debug('received response %j', response);

        var request = self.requests[requestid];

        switch (request.type) {

            case requestTypes.clients: // 获取指定房间的sid
                request.msgCount++; // 响应该请求的计数器

                // ignore if response does not contain 'clients' key
                if (!response.clients || !Array.isArray(response.clients)) return;

                for (var i = 0; i < response.clients.length; i++) {
                    request.clients[response.clients[i]] = true;
                }

                // 如果全部节点都响应该请求，则清除定时器
                if (request.msgCount === request.numsub) {
                    clearTimeout(request.timeout);
                    // 如果存在请求回调函数，则调用该函数并传入收集的值
                    if (request.callback) process.nextTick(request.callback.bind(null, null, Object.keys(request.clients)));
                    delete self.requests[requestid]; // 请求已经响应，则清除该请求记录
                }
                break;

            case requestTypes.clientRooms: // 获取指定连接加入的所有房间
                clearTimeout(request.timeout);
                // 如果存在请求回调函数，则调用该函数并传入收集的值
                if (request.callback) process.nextTick(request.callback.bind(null, null, response.rooms));
                delete self.requests[requestid]; // 请求已经响应，则清除该请求记录
                break;

            case requestTypes.allRooms: // 查询当前命名空间的所有房间
                request.msgCount++;

                // ignore if response does not contain 'rooms' key
                if (!response.rooms || !Array.isArray(response.rooms)) return;

                for (var i = 0; i < response.rooms.length; i++) {
                    request.rooms[response.rooms[i]] = true;
                }

                // 如果全部节点都响应该请求，则清除定时器
                if (request.msgCount === request.numsub) {
                    clearTimeout(request.timeout);
                    // 如果存在请求回调函数，则调用该函数并传入收集的值
                    if (request.callback) process.nextTick(request.callback.bind(null, null, Object.keys(request.rooms)));
                    delete self.requests[requestid]; // 请求已经响应，则清除该请求记录
                }
                break;

            case requestTypes.remoteJoin:
            case requestTypes.remoteLeave:
            case requestTypes.remoteDisconnect:
                clearTimeout(request.timeout);
                // 如果存在请求回调函数，则调用该函数
                if (request.callback) process.nextTick(request.callback.bind(null, null));
                delete self.requests[requestid]; // 请求已经响应，则清除该请求记录
                break;

            case requestTypes.customRequest:
                request.msgCount++;

                request.replies.push(response.data); // 收集其它节点响应的数据

                // 当收集到所有其它节点响应数据后，清空定时器，然后调用回调函数
                if (request.msgCount === request.numsub) {
                    clearTimeout(request.timeout);
                    if (request.callback) process.nextTick(request.callback.bind(null, null, request.replies));
                    delete self.requests[requestid];
                }
                break;

            default:
                debug('ignoring unknown request type: %s', request.type);
        }
    };

    /**
     * Broadcasts a packet.广播一个包
     *
     * @param {Object} packet to emit
     * @param {Object} options
     * @param {Boolean} whether the packet came from another node 该包是否来自其它节点
     * @api public
     */

    Redis.prototype.broadcast = function (packet, opts, remote) {
        packet.nsp = this.nsp.name;
        // 如果不是远程转发且不是本地节点内广播消息，则需要通过频道转发
        if (!(remote || (opts && opts.flags && opts.flags.local))) {
            // 编码消息包
            var msg = msgpack.encode([uid, packet, opts]);
            var channel = this.channel; // 命名空间内广播频道
            if (opts.rooms && opts.rooms.length === 1) { // 如果是命名空间内的单个房间内广播
                channel += opts.rooms[0] + '#'; // 频道名称需要加上房间名称
            }
            // 对于多个房间的广播，使用命名空间内广播频道
            debug('publishing message to channel %s', channel);
            pub.publish(channel, msg); // 发布消息
        }
        // 如果是远程转发或者本地节点内广播消息
        Adapter.prototype.broadcast.call(this, packet, opts);
    };


    /**
     * Get the number of subscribers of a channel，一个频道订阅者个数
     *
     * @param {String} channel
     */

    function getNumSub(channel) {
        if (pub.constructor.name != 'Cluster') { // 非集群
            // RedisClient or Redis
            return new Promise(function (resolve, reject) {
                pub.send_command('pubsub', ['numsub', channel], function (err, numsub) {
                    if (err) return reject(err);
                    resolve(parseInt(numsub[1], 10));
                });
            })
        } else { // 集群
            // Cluster
            var nodes = pub.nodes();
            return Promise.all(
                nodes.map(function (node) {
                    return node.send_command('pubsub', ['numsub', channel]);
                })
            ).then(function (values) {
                var numsub = 0;
                values.map(function (value) {
                    numsub += parseInt(value[1], 10);
                })
                return numsub;
            }).catch(function (err) {
                throw err;
            });
        }
    }

    /**
     * Gets a list of clients by sid.
     * 返回连接房间名为 rooms 的所有节点的客户端ID列表，需要跨多个节点
     *
     * @param {Array} explicit set of rooms to check.
     * @param {Function} callback
     * @api public
     */

    Redis.prototype.clients = function (rooms, fn) {
        if ('function' == typeof rooms) {
            fn = rooms;
            rooms = null;
        }

        rooms = rooms || [];

        var self = this;
        var requestid = uid2(6); // 创建请求id

        getNumSub(self.requestChannel).then(numsub => {
            debug('waiting for %d responses to "clients" request', numsub);

            var request = JSON.stringify({
                requestid: requestid, // 请求序列号
                type: requestTypes.clients, // 请求类型
                rooms: rooms // 传入房间号
            });

            // if there is no response for x second, return result
            // 指定的时间没有返回值，则返回一个超时错误
            var timeout = setTimeout(function () {
                var request = self.requests[requestid];
                if (fn) process.nextTick(fn.bind(null, new Error('timeout reached while waiting for clients response'), Object.keys(request.clients))); // 绑定对象并回调函数
                delete self.requests[requestid];
            }, self.requestsTimeout);

            self.requests[requestid] = { // 保存自己发出的请求信息
                type: requestTypes.clients, // 请求类型
                numsub: numsub, // 该请求应该被响应的次数
                msgCount: 0,  // 该请求被响应次数计数器
                clients: {}, //
                callback: fn, // 回调函数
                timeout: timeout // 超时时间定期器句柄
            };

            pub.publish(self.requestChannel, request); // 发布请求
        }).catch(err => {
            self.emit('error', err);
            if (fn) fn(err); // 发生错误，则传入错误
        });
    };

    /**
     * Gets the list of rooms a given client has joined.
     * 获取客户端连接加入的所有房间，只会有一个包含指定连接的节点响应请求。
     *
     * @param {String} client id
     * @param {Function} callback
     * @api public
     */

    Redis.prototype.clientRooms = function (id, fn) {

        var self = this;
        var requestid = uid2(6);

        var rooms = this.sids[id]; // 首先在本地查找，如果连接当前服务器，则直接返回房间

        if (rooms) { // 回调处理
            if (fn) process.nextTick(fn.bind(null, null, Object.keys(rooms)));
            return;
        }

        // 如果不是本地连接，则需要发送请求给其它节点服务器
        var request = JSON.stringify({
            requestid: requestid,
            type: requestTypes.clientRooms,
            sid: id
        });

        // if there is no response for x second, return result
        var timeout = setTimeout(function () {
            if (fn) process.nextTick(fn.bind(null, new Error('timeout reached while waiting for rooms response')));
            delete self.requests[requestid];
        }, self.requestsTimeout);

        self.requests[requestid] = {
            type: requestTypes.clientRooms,
            callback: fn,
            timeout: timeout
        };

        pub.publish(self.requestChannel, request);
    };

    /**
     * Gets the list of all rooms (accross every node)
     * 返回命名空间内的所有房间(跨每个节点)
     *
     * @param {Function} callback
     * @api public
     */

    Redis.prototype.allRooms = function (fn) {

        var self = this;
        var requestid = uid2(6);

        getNumSub(self.requestChannel).then(numsub => {
            debug('waiting for %d responses to "allRooms" request', numsub);

            var request = JSON.stringify({
                requestid: requestid,
                type: requestTypes.allRooms
            });

            // if there is no response for x second, return result
            var timeout = setTimeout(function () {
                var request = self.requests[requestid];
                if (fn) process.nextTick(fn.bind(null, new Error('timeout reached while waiting for allRooms response'), Object.keys(request.rooms)));
                delete self.requests[requestid];
            }, self.requestsTimeout);

            self.requests[requestid] = {
                type: requestTypes.allRooms,
                numsub: numsub,
                msgCount: 0,
                rooms: {},
                callback: fn,
                timeout: timeout
            };

            pub.publish(self.requestChannel, request);
        }).catch(err => {
            self.emit('error', err);
            if (fn) fn(err);
        });
    };

    /**
     * Makes the socket with the given id join the room
     * 连接加入到指定房间，会跨节点，找到连接所在的节点来执行加入
     *
     * @param {String} socket id
     * @param {String} room name
     * @param {Function} callback
     * @api public
     */

    Redis.prototype.remoteJoin = function (id, room, fn) {

        var self = this;
        var requestid = uid2(6);

        var socket = this.nsp.connected[id]; // 如果当前节点包含该连接，则直接调用加入
        if (socket) {
            socket.join(room, fn);
            return;
        }

        // 如果当前节点不包括该连接，则需要发送请求
        var request = JSON.stringify({
            requestid: requestid,
            type: requestTypes.remoteJoin,
            sid: id,
            room: room
        });

        // if there is no response for x second, return result
        var timeout = setTimeout(function () {
            if (fn) process.nextTick(fn.bind(null, new Error('timeout reached while waiting for remoteJoin response')));
            delete self.requests[requestid];
        }, self.requestsTimeout);

        self.requests[requestid] = {
            type: requestTypes.remoteJoin,
            callback: fn,
            timeout: timeout
        };

        pub.publish(self.requestChannel, request);
    };

    /**
     * Makes the socket with the given id leave the room
     * 连接离开指定房间，会跨节点，找到连接所在的节点来执行离开
     *
     * @param {String} socket id
     * @param {String} room name
     * @param {Function} callback
     * @api public
     */

    Redis.prototype.remoteLeave = function (id, room, fn) {

        var self = this;
        var requestid = uid2(6);

        // 如果连接在当前节点，则直接执行离开动作
        var socket = this.nsp.connected[id];
        if (socket) {
            socket.leave(room, fn);
            return;
        }

        // 如果连接在其它节点，则需要发送请求
        var request = JSON.stringify({
            requestid: requestid,
            type: requestTypes.remoteLeave,
            sid: id,
            room: room
        });

        // if there is no response for x second, return result
        var timeout = setTimeout(function () {
            if (fn) process.nextTick(fn.bind(null, new Error('timeout reached while waiting for remoteLeave response')));
            delete self.requests[requestid];
        }, self.requestsTimeout);

        self.requests[requestid] = {
            type: requestTypes.remoteLeave,
            callback: fn,
            timeout: timeout
        };

        pub.publish(self.requestChannel, request);
    };

    /**
     * Makes the socket with the given id to be disconnected forcefully
     * 使具有给定id的套接字强行断开连接，会跨节点，找到连接所在的节点来执行断开
     * @param {String} socket id
     * @param {Boolean} close if `true`, closes the underlying connection
     * @param {Function} callback
     */

    Redis.prototype.remoteDisconnect = function (id, close, fn) {
        var self = this;
        var requestid = uid2(6);

        // 如果连接在当前节点服务器上，则直接执行
        var socket = this.nsp.connected[id];
        if (socket) {
            socket.disconnect(close);
            if (fn) process.nextTick(fn.bind(null, null));
            return;
        }

        // 否则，需要发送请求
        var request = JSON.stringify({
            requestid: requestid,
            type: requestTypes.remoteDisconnect,
            sid: id,
            close: close
        });

        // if there is no response for x second, return result
        var timeout = setTimeout(function () {
            if (fn) process.nextTick(fn.bind(null, new Error('timeout reached while waiting for remoteDisconnect response')));
            delete self.requests[requestid];
        }, self.requestsTimeout);

        self.requests[requestid] = {
            type: requestTypes.remoteDisconnect,
            callback: fn,
            timeout: timeout
        };

        pub.publish(self.requestChannel, request);
    };

    /**
     * Sends a new custom request to other nodes
     * 发送一个定制请求到其它节点
     *
     * @param {Object} data (no binary)
     * @param {Function} callback
     * @api public
     */

    Redis.prototype.customRequest = function (data, fn) {
        if (typeof data === 'function') {
            fn = data;
            data = null;
        }

        var self = this;
        var requestid = uid2(6);

        getNumSub(self.requestChannel).then(numsub => {
            debug('waiting for %d responses to "customRequest" request', numsub);

            var request = JSON.stringify({
                requestid: requestid,
                type: requestTypes.customRequest,
                data: data
            });

            // if there is no response for x second, return result
            var timeout = setTimeout(function () {
                var request = self.requests[requestid];
                if (fn) process.nextTick(fn.bind(null, new Error('timeout reached while waiting for customRequest response'), request.replies));
                delete self.requests[requestid];
            }, self.requestsTimeout);

            self.requests[requestid] = {
                type: requestTypes.customRequest,
                numsub: numsub,
                msgCount: 0,
                replies: [], // 收集其它节点响应的数据
                callback: fn,
                timeout: timeout
            };

            pub.publish(self.requestChannel, request);
        }).catch(err => {
            self.emit('error', err);
            if (fn) fn(err);
        });
    };

    // 静态属性
    Redis.uid = uid; // 标识该服务器id
    Redis.pubClient = pub;
    Redis.subClient = sub;
    Redis.prefix = prefix;
    Redis.requestsTimeout = requestsTimeout;

    return Redis; // 返回Redis构造函数

}
